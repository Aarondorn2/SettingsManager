using System.Security.Cryptography;

namespace SettingsManager.SettingsManagerProviders;

/// <summary>
/// This implementation provides nearly everything needed to encrypt and decrypt
/// properties of settings and configs using an AES algorithm. The constructor
/// requires you provide your own symmetric key.
///
/// For more information on encrypting properties: <see cref="EncryptedProperty{T}"/>
/// </summary>
public class AesCryptographyProvider : ICryptographyProvider
{
    private const int IvLength = 16;
    private readonly byte[] _symmetricKey;
    public AesCryptographyProvider(byte[] symmetricKey)
    {
        _symmetricKey = symmetricKey;
    }

    /// <summary>
    /// This method accepts a string, encrypts it, appends the IV,
    /// and then encodes the entire result as a B64 string.
    /// </summary>
    /// <param name="stringToEncrypt"></param>
    /// <returns></returns>
    public string EncryptString(string stringToEncrypt)
    {
        var iv = GenerateCryptoRandom(IvLength);
        
        using var aes = new AesManaged();
        var encryptor = aes.CreateEncryptor(_symmetricKey, iv);
        
        using var ms = new MemoryStream();
        
        using (var cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))
        using (var sw = new StreamWriter(cs))
        {
            sw.Write(stringToEncrypt);
        }
        
        return Convert.ToBase64String(ms.ToArray().Concat(iv).ToArray());
    }

    /// <summary>
    /// This method accepts a string, decodes it from a B64 string, extracts
    /// the IV from the end of the encrypted value, and then decrypts the value.
    /// </summary>
    /// <param name="encryptedString"></param>
    /// <returns></returns>
    public string DecryptString(string encryptedString)
    {
        var bytes = Convert.FromBase64String(encryptedString);
        var encrypted = bytes[..^IvLength];
        var iv = bytes[^IvLength..];
        
        using var aes = new AesManaged();
        var decryptor = aes.CreateDecryptor(_symmetricKey, iv);
        
        using var ms = new MemoryStream(encrypted);
        using var cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Read);
        using var reader = new StreamReader(cs);
                       
        return reader.ReadToEnd();
    }

    /// <summary>
    /// This method provides a crytographically secure random sequence of bytes
    /// to be used as an Initialization Vector for AES encryption.
    /// </summary>
    /// <param name="length">how long you would like the generated byte[]</param>
    /// <returns></returns>
    private static byte[] GenerateCryptoRandom(int length = IvLength)
    {
        using var rng = RandomNumberGenerator.Create();
        var random = new byte[length];
        rng.GetBytes(random);
        
        return random;
    }
}
